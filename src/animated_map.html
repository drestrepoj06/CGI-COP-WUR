<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Leaflet Live Vehicle Animation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
</head>
<body>
<div id="map"></div>

<script>
  //__INSERT_RAILS_HERE__   
  //__INSERT_AMBULANCE_STATIONS_HERE__
  //__INSERT_ROUTE_POINTS_HERE__

  const trainMarkers = {};
  const ambulanceMarkers = {};

  // Initialize Map
  function initMap() {
    const map = L.map('map').setView([52.1, 5.1], 12);

    // Mapbox Light Gray Tile Layer
    L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/navigation-day-v1/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoicnVvdGFsIiwiYSI6ImNtYmh5ZjA5eDAyN3kyanI0cGE2b295MW0ifQ.Cf2xGVOEXF-7hbunq3soyw', {
      tileSize: 512,
      zoomOffset: -1,
      attribution: 'Â© <a href="https://www.mapbox.com/about/maps/">Mapbox</a> Â© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    L.circle([52.094442, 5.092170], {
      radius: 6125,
      color: 'black',
      fillColor: '#f03',
      fillOpacity: 0,
      dashArray: '10, 10'
    }).addTo(map);

    // Render ambulance stations
    L.geoJSON(ambulanceStationsData, {
        pointToLayer: function (feature, latlng) {
            return L.rectangle([
                [latlng.lat - 0.001, latlng.lng - 0.003],
                [latlng.lat + 0.001, latlng.lng + 0.003]
            ], {
                color: 'yellow',
                weight: 1,
                fillColor: 'yellow',
                fillOpacity: 1
            });
        }
    }).addTo(map);

    // Render rails
    L.geoJSON(railsData, {
        style: {
        color: 'black',
        weight: 2,
        opacity: 0.8
        }
    }).addTo(map);

    L.polyline(routePoints, { 
        color: '#FF00FF',  // æµ…ç´«è‰² (æ·¡ç´«ç½—å…°)
        weight: 7,         // çº¿æ¡å®½åº¦
        opacity: 0.9       // è®¾ç½®é€æ˜åº¦ (0.0 å®Œå…¨é€æ˜ - 1.0 å®Œå…¨ä¸é€æ˜)
    }).addTo(map);


    return map;
  }

  const map = initMap();


  function showIncidentPopup(lat, lng, trainId, severity, description) {
    const popupContent = `
        <b>ğŸš¨ Train Incident</b><br>
        <b>Train ID:</b> ${trainId}<br>
        <b>Severity:</b> ${severity}<br>
        <b>Description:</b> ${description}
    `;

    const icon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/drestrepoj06/CGI-COP-WUR/CRUD/src/vec/icngb25_stopped.png',
        iconSize: [40, 40],
        iconAnchor: [20, 40],
        popupAnchor: [0, -30]
    });

    const marker = L.marker([lat, lng], { icon: icon })
        .addTo(map)
        .bindPopup(popupContent)
        .openPopup();

    map.setView([lat, lng], 15);  // Zoom to the incident
    }

    

  // Utility function for formatting timestamps
  function formatTimestamp(unixMs) {
    return unixMs
        ? new Date(unixMs).toLocaleString('en-GB', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            day: '2-digit',
            month: 'short'  // e.g. "Jun"
        })
        : '';
  }

  function updateTrainPositions(trains) {
      trains.forEach(train => {
          try {
              const id = train[0]; // Extract Train ID
              const geojson = JSON.parse(train[1]); // Parse GeoJSON string
              const coordinates = geojson.coordinates; // Extract coordinates (lng, lat)
              const timestamp = Number(train[1].slice(-15,-2)); // Extract timestamp

              // Parse the info JSON to get the status
              let info = {};
              try {
                  info = JSON.parse(train[2][1]);
              } catch (e) {
                  info = {};
              }
              const isStopped = info.status === false;

              // Set color based on status
            //   const color = isStopped ? "purple" : "blue";

              // Convert [lng, lat] â†’ [lat, lng] for Leaflet
              const latlng = [coordinates[1], coordinates[0]];

              const popupContent = `ğŸš† Train ${id}<br/>â° ${formatTimestamp(timestamp)}<br/>Status: ${isStopped ? "Stopped" : "Active"}`;
            
              const trainIcon = isStopped ? (L.icon({
                iconUrl: 'https://raw.githubusercontent.com/drestrepoj06/CGI-COP-WUR/CRUD/src/vec/icngb25_stopped.png',
                iconSize: [40, 40], // å›¾æ ‡å¤§å°
                iconAnchor: [16, 16], // å›¾æ ‡ä¸­å¿ƒç‚¹
                popupAnchor: [0, -16] // å¼¹å‡ºæ¡†åç§»é‡
            }))
            : (L.icon({
                iconUrl: 'https://raw.githubusercontent.com/drestrepoj06/CGI-COP-WUR/CRUD/src/vec/icngb25.png',
                iconSize: [32, 32], // å›¾æ ‡å¤§å°
                iconAnchor: [16, 16], // å›¾æ ‡ä¸­å¿ƒç‚¹
                popupAnchor: [0, -16] // å¼¹å‡ºæ¡†åç§»é‡
            }));

            if (!trainMarkers[id]) {
                trainMarkers[id] = L.marker(latlng, { icon: trainIcon })
                    .addTo(map)
                    .bindPopup(popupContent);
            } else {
                trainMarkers[id].setLatLng(latlng); // **æ›´æ–°ä½ç½®**
                if (trainMarkers[id].isPopupOpen()) {
                    trainMarkers[id].getPopup().setContent(popupContent);
                }
            }
          } catch (error) {
              console.error("ğŸš¨ Error parsing train data:", train, error);
          }
      });
  }


  function initTrainWebSocket() {
    const trainSocket = new WebSocket("ws://localhost:8000/ws/scan");

    trainSocket.onopen = () => {
        trainSocket.send(JSON.stringify({ collection: "train" })); // Request train data
    };

    trainSocket.onmessage = event => {
        const data = JSON.parse(event.data);
        // console.log("ğŸš† Train Data Received:", data);
        
        if (data.collection === "train") {
            updateTrainPositions(data.data); // Update train markers
        }
    };

    trainSocket.onerror = error => console.error("ğŸš¨ Train WebSocket Error:", error);
  }
 let incidentMarker = null;

 function showIncidentPopup(lat, lng, trainId, severity, description) {
    // Update existing marker if trainId is found
    if (trainMarkers[trainId]) {
        const popupContent = `
            <b>ğŸš¨ Train Incident</b><br>
            <b>Train ID:</b> ${trainId}<br>
            <b>Severity:</b> ${severity}<br>
            <b>Description:</b> ${description}
        `;
        trainMarkers[trainId].bindPopup(popupContent).openPopup();
        map.setView([lat, lng], 15, { animate: true });
    } else {
        // Fallback: if marker not found, create a temporary incident marker
        if (incidentMarker) {
            map.removeLayer(incidentMarker);
        }

        const icon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/drestrepoj06/CGI-COP-WUR/CRUD/src/vec/icngb25_stopped.png',
            iconSize: [40, 40],
            iconAnchor: [20, 40],
            popupAnchor: [0, -30]
        });

        const popupContent = `
            <b>ğŸš¨ Train Incident</b><br>
            <b>Train ID:</b> ${trainId}<br>
            <b>Severity:</b> ${severity}<br>
            <b>Description:</b> ${description}
        `;

        incidentMarker = L.marker([lat, lng], { icon: icon })
            .addTo(map)
            .bindPopup(popupContent)
            .openPopup();

        map.setView([lat, lng], 15, { animate: true });
    }
 }

  function updateAmbulancePositions(ambulances, ambuPath) {
    let ambuPathData = {}; // å­˜å‚¨è·¯å¾„æ•°æ®

    // å¤„ç† ambuPath æ•°æ®
    ambuPath.forEach(amP => {
        try {
            const [amP_id, amP_timestamp] = amP[0].split("_");
            const amP_geojson = JSON.parse(amP[1]);
            const [amP_lng, amP_lat] = amP_geojson.coordinates; // æå–åæ ‡ (lng, lat)

            // ä»¥ amP_id ä¸ºç¬¬ä¸€çº§ï¼ŒamP_timestamp ä¸ºç¬¬äºŒçº§
            if (!ambuPathData[amP_id]) {
                ambuPathData[amP_id] = {};
            }
            ambuPathData[amP_id][amP_timestamp] = { lng: amP_lng, lat: amP_lat };
        } catch (error) {
            console.error("ğŸš¨ Error parsing Ambu Path:", amP, error);
        }
    });

    // **æ›´æ–°æ•‘æŠ¤è½¦ä½ç½®**
    ambulances.forEach(amb => {
        try {
            const id = amb[0]; // è·å–æ•‘æŠ¤è½¦ ID
            const geojson = JSON.parse(amb[1]); // è§£æ GeoJSON å­—ç¬¦ä¸²
            const coordinates = geojson.coordinates; // è·å–åæ ‡ (lng, lat)
            const timestamp = Number(amb[1].slice(-15, -2)); // è§£ææ—¶é—´æˆ³

            let latlng = [coordinates[1], coordinates[0]];

            // **å¦‚æœå­˜åœ¨å¯¹åº”çš„è·¯å¾„æ•°æ®ï¼Œåˆ™æ›¿æ¢åæ ‡**
            if (ambuPathData[id]) {
                const timestamps = Object.keys(ambuPathData[id]).map(Number).sort((a, b) => a - b);
                let closestTimestamp = timestamps[0];

                for (const t of timestamps) {
                    if (t <= timestamp) {
                        closestTimestamp = t;
                    } else {
                        break;
                    }
                }

                if (timestamp > timestamps[timestamps.length - 1]) {
                    closestTimestamp = timestamps[timestamps.length - 1];
                }

                const pathCoords = ambuPathData[id][closestTimestamp];
                latlng = [pathCoords.lat, pathCoords.lng];
                console.log(`IF ğŸš‘ LatLng: (${latlng[0]}, ${latlng[1]}), closestTimestamp: ${closestTimestamp}, ID: ${id}`);

            }
            console.log(`ğŸš‘ LatLng: (${latlng[0]}, ${latlng[1]}), Timestamp: ${timestamp}, ID: ${id}`);

            const popupContent = `ğŸš‘ Ambulance ${id}<br/>â° ${formatTimestamp(timestamp)}`;


            const ambulanceIcon = L.icon({
                iconUrl: 'https://raw.githubusercontent.com/drestrepoj06/CGI-COP-WUR/CRUD/src/vec/ambulance-100.png',  // æ›¿æ¢ä¸ºå®é™…æ•‘æŠ¤è½¦å›¾æ ‡çš„è·¯å¾„
                iconSize: [32, 32], // å›¾æ ‡å¤§å°
                iconAnchor: [16, 16], // å›¾æ ‡ä¸­å¿ƒç‚¹
                popupAnchor: [0, -16] // å¼¹å‡ºæ¡†åç§»é‡
            });

            // **å¼ºåˆ¶æ›´æ–°æ•‘æŠ¤è½¦ä½ç½®**
            if (!ambulanceMarkers[id]) {
                ambulanceMarkers[id] = L.marker(latlng, { icon: ambulanceIcon })
                    .addTo(map)
                    .bindPopup(popupContent);
                // ambulanceMarkers[id] = L.circleMarker(latlng, {
                //     radius: 6,
                //     color: "red",
                //     fillColor: "red",
                //     fillOpacity: 0.4
                // }).addTo(map).bindPopup(popupContent);
            } else {
                ambulanceMarkers[id].setLatLng(latlng); // **æ›´æ–°ä½ç½®**
                if (ambulanceMarkers[id].isPopupOpen()) {
                    ambulanceMarkers[id].getPopup().setContent(popupContent);
                }
            }
        } catch (error) {
            console.error("ğŸš¨ Error parsing ambulance data:", amb, error);
        }
    });

    // **å¼ºåˆ¶åˆ·æ–°åœ°å›¾**
    map.invalidateSize();

  }




function initAmbulanceWebSocket() {
    const ambulanceSocket = new WebSocket("ws://localhost:8000/ws/scan");
    const ambuPathSocket = new WebSocket("ws://localhost:8000/ws/scan");

    
    let ambulanceData = [];
    let ambuPathData = []; // é»˜è®¤å€¼ä¸ºç©ºæ•°ç»„ï¼Œé¿å… undefined

    ambulanceSocket.onopen = () => {
        ambulanceSocket.send(JSON.stringify({ collection: "ambulance" })); // è¯·æ±‚æ•‘æŠ¤è½¦æ•°æ®
    };

    ambuPathSocket.onopen = () => {
        ambuPathSocket.send(JSON.stringify({ collection: "ambu_path" })); // è¯·æ±‚è·¯å¾„æ•°æ®
    };

    ambulanceSocket.onmessage = event => {
        const data = JSON.parse(event.data);
        console.log("ğŸš‘ Ambulance Data Received:", data);
        
        if (data.collection === "ambulance") {
            ambulanceData = data.data || []; // ç¡®ä¿æ•°æ®ä¸ä¸ºç©º
        }

        // è°ƒç”¨ updateAmbulancePositions æ—¶ï¼Œç¡®ä¿ `ambuPathData` ä¸ºç©ºæ—¶ä½¿ç”¨ `[]`
        updateAmbulancePositions(ambulanceData, ambuPathData || []);
    };

    ambuPathSocket.onmessage = event => {
        const data = JSON.parse(event.data);
        // console.log("ğŸ›£ï¸ Ambulance Path Data Received:", data);

        // å¦‚æœæ”¶åˆ°çš„æ•°æ®ä¸åŒ…å« `ambu_path`ï¼Œå°±å¿½ç•¥æ›´æ–°
        if (data.collection === "ambu_path") {
            ambuPathData = data.data || []; // ç¡®ä¿æ•°æ®ä¸ä¸ºç©º
            updateAmbulancePositions(ambulanceData, ambuPathData);
        } else {
            console.warn("âš ï¸ 'ambu_path' collection not found, skipping update.");
        }
    };

    ambulanceSocket.onerror = error => console.error("ğŸš¨ Ambulance WebSocket Error:", error);
    ambuPathSocket.onerror = error => console.error("ğŸš¨ Ambulance Path WebSocket Error:", error);
  }



  // Initialize both WebSocket connections
  initTrainWebSocket();
  initAmbulanceWebSocket();
  
//     // **å®šæœŸæ›´æ–°æ•°æ®**
//   setInterval(() => {
//     initAmbulanceWebSocket(); // æ¯ 5 ç§’é‡æ–°è¯·æ±‚æ•°æ®
//   }, 5000);






  function railsegmentWebSocket() {
    const railsegmentSocket = new WebSocket("ws://localhost:8000/ws/scan");

    railsegmentSocket.onopen = () => {
        railsegmentSocket.send(JSON.stringify({ collection: "railsegment" })); // Request railsegment data
    };

    railsegmentSocket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        // console.log("Total Railsegments Received:", data.data.length);
        // console.log("Received Data:", data); // Debugging: Check full response

        if (data.collection === "railsegment" && Array.isArray(data.data)) {
            data.data.forEach(entry => {
                try {
                    const segmentId = entry[0];  // Segment ID
                    const geojsonStr = entry[1]; // GeoJSON as string
                    const metadataStr = entry[2][1]; // Extract the correct JSON string
                    const metadata = JSON.parse(metadataStr); // Parse metadata as JSON

                    const geojson = JSON.parse(geojsonStr); // Convert GeoJSON string to object
                    const coordinates = geojson.coordinates;

                    if (geojson.type === "Polygon") {
                        addPolygonToMap(coordinates, segmentId, metadata);
                    }
                } catch (error) {
                    console.error("ğŸš¨ Error parsing segment:", entry, error);
                }
            });
        } else {
            console.warn("ğŸš¨ Unexpected response format:", data);
        }
    };

    railsegmentSocket.onerror = (error) => console.error("WebSocket Error:", error);
  }

  function addPolygonToMap(coordinates, segmentId, metadata) {
    // console.log(`Rendering Segment: ${segmentId}`, coordinates);

    // Convert [lng, lat] â†’ [lat, lng] for Leaflet
    const formattedCoords = coordinates[0].map(coord => [coord[1], coord[0]]);

    // Create the polygon with enhanced transparency
    const polygon = L.polygon(formattedCoords, {
        color: "blue",      // Border color
        fillColor: "blue",  // Fill color
        weight: 2,          // Border thickness
        fillOpacity: 0.2    // Increased transparency
    }).addTo(map);

    // Automatically remove the polygon after 0.5 seconds
    setTimeout(() => {
        map.removeLayer(polygon);
    }, 500);

    // Bind a click event to show segment info
    polygon.on("click", () => {
        const popupContent = `<b>ğŸš† Segment ID:</b> ${segmentId}<br>
                              <b>Status:</b> ${metadata.status || "Unknown"}<br>
                              <b>Shape Length:</b> ${metadata.SHAPE_Length || "N/A"}<br>
                              <b>Shape Area:</b> ${metadata.SHAPE_Area || "N/A"}`;
        polygon.bindPopup(popupContent).openPopup();
    });
}



  // railsegmentWebSocket();


</script>
</body>
</html>
