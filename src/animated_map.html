<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Leaflet Live Vehicle Animation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
</head>
<body>
<div id="map"></div>

<script>
  //__INSERT_RAILS_HERE__   
  //__INSERT_AMBULANCE_STATIONS_HERE__
  //__INSERT_ROUTE_POINTS_HERE__

  const trainMarkers = {};
  const ambulanceMarkers = {};

  // Initialize Map
  function initMap() {
    const map = L.map('map').setView([52.1, 5.1], 12);

    // Mapbox Light Gray Tile Layer
    L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/navigation-day-v1/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoicnVvdGFsIiwiYSI6ImNtYmh5ZjA5eDAyN3kyanI0cGE2b295MW0ifQ.Cf2xGVOEXF-7hbunq3soyw', {
      tileSize: 512,
      zoomOffset: -1,
      attribution: '¬© <a href="https://www.mapbox.com/about/maps/">Mapbox</a> ¬© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    L.circle([52.094442, 5.092170], {
      radius: 6125,
      color: 'black',
      fillColor: '#f03',
      fillOpacity: 0,
      dashArray: '10, 10'
    }).addTo(map);

    // Render ambulance stations
    L.geoJSON(ambulanceStationsData, {
        pointToLayer: function (feature, latlng) {
            return L.rectangle([
                [latlng.lat - 0.001, latlng.lng - 0.003],
                [latlng.lat + 0.001, latlng.lng + 0.003]
            ], {
                color: 'yellow',
                weight: 1,
                fillColor: 'yellow',
                fillOpacity: 1
            });
        }
    }).addTo(map);

    // Render rails
    L.geoJSON(railsData, {
        style: {
        color: 'black',
        weight: 2,
        opacity: 0.8
        }
    }).addTo(map);

    L.polyline(routePoints, { 
        color: '#FF00FF',  // ÊµÖÁ¥´Ëâ≤ (Ê∑°Á¥´ÁΩóÂÖ∞)
        weight: 7,         // Á∫øÊù°ÂÆΩÂ∫¶
        opacity: 0.9       // ËÆæÁΩÆÈÄèÊòéÂ∫¶ (0.0 ÂÆåÂÖ®ÈÄèÊòé - 1.0 ÂÆåÂÖ®‰∏çÈÄèÊòé)
    }).addTo(map);


    return map;
  }

  const map = initMap();

  // Utility function for formatting timestamps
  function formatTimestamp(unixMs) {
    return unixMs
        ? new Date(unixMs).toLocaleString('en-GB', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            day: '2-digit',
            month: 'short'  // e.g. "Jun"
        })
        : '';
  }

  function updateTrainPositions(trains) {
      trains.forEach(train => {
          try {
              const id = train[0]; // Extract Train ID
              const geojson = JSON.parse(train[1]); // Parse GeoJSON string
              const coordinates = geojson.coordinates; // Extract coordinates (lng, lat)
              const timestamp = Number(train[1].slice(-15,-2)); // Extract timestamp

              // Parse the info JSON to get the status
              let info = {};
              try {
                  info = JSON.parse(train[2][1]);
              } catch (e) {
                  info = {};
              }
              const isStopped = info.status === false;

              // Set color based on status
              const color = isStopped ? "purple" : "blue";

              // Convert [lng, lat] ‚Üí [lat, lng] for Leaflet
              const latlng = [coordinates[1], coordinates[0]];

              const popupContent = `üöÜ Train ${id}<br/>‚è∞ ${formatTimestamp(timestamp)}<br/>Status: ${isStopped ? "Stopped" : "Active"}`;

              if (!trainMarkers[id]) {
                  trainMarkers[id] = L.circleMarker(latlng, {
                      radius: 6,
                      color: color,
                      fillColor: color,
                      fillOpacity: 0.8
                  }).addTo(map).bindPopup(popupContent);
              } else {
                  trainMarkers[id].setLatLng(latlng);
                  trainMarkers[id].setStyle({ color: color, fillColor: color });
                  if (trainMarkers[id].isPopupOpen()) {
                      trainMarkers[id].getPopup().setContent(popupContent);
                  }
              }
          } catch (error) {
              console.error("üö® Error parsing train data:", train, error);
          }
      });
  }


  // // WebSocket connection to fetch live positions
  // function initWebSocket() {
  //   const socket = new WebSocket("ws://localhost:8000/ws/positions");

  //   socket.onmessage = event => {
  //     const data = JSON.parse(event.data);
  //     updateTrainPositions(data.train);
  //     updateAmbulancePositions(data.ambulance);
  //   };
  // }

  function initTrainWebSocket() {
    const trainSocket = new WebSocket("ws://localhost:8000/ws/scan");

    trainSocket.onopen = () => {
        trainSocket.send(JSON.stringify({ collection: "train" })); // Request train data
    };

    trainSocket.onmessage = event => {
        const data = JSON.parse(event.data);
        // console.log("üöÜ Train Data Received:", data);
        
        if (data.collection === "train") {
            updateTrainPositions(data.data); // Update train markers
        }
    };

    trainSocket.onerror = error => console.error("üö® Train WebSocket Error:", error);
  }



  function updateAmbulancePositions(ambulances, ambuPath) {
    let ambuPathData = {}; // Â≠òÂÇ®Ë∑ØÂæÑÊï∞ÊçÆ

    // Â§ÑÁêÜ ambuPath Êï∞ÊçÆ
    ambuPath.forEach(amP => {
        try {
            const [amP_id, amP_timestamp] = amP[0].split("_");
            const amP_geojson = JSON.parse(amP[1]);
            const [amP_lng, amP_lat] = amP_geojson.coordinates; // ÊèêÂèñÂùêÊ†á (lng, lat)

            // ‰ª• amP_id ‰∏∫Á¨¨‰∏ÄÁ∫ßÔºåamP_timestamp ‰∏∫Á¨¨‰∫åÁ∫ß
            if (!ambuPathData[amP_id]) {
                ambuPathData[amP_id] = {};
            }
            ambuPathData[amP_id][amP_timestamp] = { lng: amP_lng, lat: amP_lat };
        } catch (error) {
            console.error("üö® Error parsing Ambu Path:", amP, error);
        }
    });

    // **Êõ¥Êñ∞ÊïëÊä§ËΩ¶‰ΩçÁΩÆ**
    ambulances.forEach(amb => {
        try {
            const id = amb[0]; // Ëé∑ÂèñÊïëÊä§ËΩ¶ ID
            const geojson = JSON.parse(amb[1]); // Ëß£Êûê GeoJSON Â≠óÁ¨¶‰∏≤
            const coordinates = geojson.coordinates; // Ëé∑ÂèñÂùêÊ†á (lng, lat)
            const timestamp = Number(amb[1].slice(-15, -2)); // Ëß£ÊûêÊó∂Èó¥Êà≥

            let latlng = [coordinates[1], coordinates[0]];

            // **Â¶ÇÊûúÂ≠òÂú®ÂØπÂ∫îÁöÑË∑ØÂæÑÊï∞ÊçÆÔºåÂàôÊõøÊç¢ÂùêÊ†á**
            if (ambuPathData[id]) {
                const timestamps = Object.keys(ambuPathData[id]).map(Number).sort((a, b) => a - b);
                let closestTimestamp = timestamps[0];

                for (const t of timestamps) {
                    if (t <= timestamp) {
                        closestTimestamp = t;
                    } else {
                        break;
                    }
                }

                if (timestamp > timestamps[timestamps.length - 1]) {
                    closestTimestamp = timestamps[timestamps.length - 1];
                }

                const pathCoords = ambuPathData[id][closestTimestamp];
                latlng = [pathCoords.lat, pathCoords.lng];
                console.log(`IF üöë LatLng: (${latlng[0]}, ${latlng[1]}), closestTimestamp: ${closestTimestamp}, ID: ${id}`);

            }
            console.log(`üöë LatLng: (${latlng[0]}, ${latlng[1]}), Timestamp: ${timestamp}, ID: ${id}`);

            const popupContent = `üöë Ambulance ${id}<br/>‚è∞ ${formatTimestamp(timestamp)}`;

            // **Âº∫Âà∂Êõ¥Êñ∞ÊïëÊä§ËΩ¶‰ΩçÁΩÆ**
            if (!ambulanceMarkers[id]) {
                ambulanceMarkers[id] = L.circleMarker(latlng, {
                    radius: 6,
                    color: "red",
                    fillColor: "red",
                    fillOpacity: 0.4
                }).addTo(map).bindPopup(popupContent);
            } else {
                ambulanceMarkers[id].setLatLng(latlng); // **Êõ¥Êñ∞‰ΩçÁΩÆ**
                if (ambulanceMarkers[id].isPopupOpen()) {
                    ambulanceMarkers[id].getPopup().setContent(popupContent);
                }
            }
        } catch (error) {
            console.error("üö® Error parsing ambulance data:", amb, error);
        }
    });

    // **Âº∫Âà∂Âà∑Êñ∞Âú∞Âõæ**
    map.invalidateSize();




    // ambulances.forEach(amb => {
    //     try {
    //         const id = amb[0]; // Extract Ambulance ID
    //         const geojson = JSON.parse(amb[1]); // Parse GeoJSON string
    //         const coordinates = geojson.coordinates; // Extract coordinates (lng, lat)
    //         const timestamp = Number(amb[1].slice(-15,-2)); // Extract timestamp

    //         // Convert [lng, lat] ‚Üí [lat, lng] for Leaflet
    //         const latlng = [coordinates[1], coordinates[0]];

    //         const popupContent = `üöë Ambulance ${id}<br/>‚è∞ ${formatTimestamp(timestamp)}`;

    //         if (!ambulanceMarkers[id]) {
    //             ambulanceMarkers[id] = L.circleMarker(latlng, {
    //                 radius: 6,
    //                 color: "red",
    //                 fillColor: "red",
    //                 fillOpacity: 0.4
    //             }).addTo(map).bindPopup(popupContent);
    //         } else {
    //             ambulanceMarkers[id].setLatLng(latlng);
    //             if (ambulanceMarkers[id].isPopupOpen()) {
    //                 ambulanceMarkers[id].getPopup().setContent(popupContent);
    //             }
    //         }
    //     } catch (error) {
    //         console.error("üö® Error parsing ambulance data:", amb, error);
    //     }
    // });
  }




function initAmbulanceWebSocket() {
    const ambulanceSocket = new WebSocket("ws://localhost:8000/ws/scan");
    const ambuPathSocket = new WebSocket("ws://localhost:8000/ws/scan");

    
    let ambulanceData = [];
    let ambuPathData = []; // ÈªòËÆ§ÂÄº‰∏∫Á©∫Êï∞ÁªÑÔºåÈÅøÂÖç undefined

    ambulanceSocket.onopen = () => {
        ambulanceSocket.send(JSON.stringify({ collection: "ambulance" })); // ËØ∑Ê±ÇÊïëÊä§ËΩ¶Êï∞ÊçÆ
    };

    ambuPathSocket.onopen = () => {
        ambuPathSocket.send(JSON.stringify({ collection: "ambu_path" })); // ËØ∑Ê±ÇË∑ØÂæÑÊï∞ÊçÆ
    };

    ambulanceSocket.onmessage = event => {
        const data = JSON.parse(event.data);
        console.log("üöë Ambulance Data Received:", data);
        
        if (data.collection === "ambulance") {
            ambulanceData = data.data || []; // Á°Æ‰øùÊï∞ÊçÆ‰∏ç‰∏∫Á©∫
        }

        // Ë∞ÉÁî® updateAmbulancePositions Êó∂ÔºåÁ°Æ‰øù `ambuPathData` ‰∏∫Á©∫Êó∂‰ΩøÁî® `[]`
        updateAmbulancePositions(ambulanceData, ambuPathData || []);
    };

    ambuPathSocket.onmessage = event => {
        const data = JSON.parse(event.data);
        // console.log("üõ£Ô∏è Ambulance Path Data Received:", data);

        // Â¶ÇÊûúÊî∂Âà∞ÁöÑÊï∞ÊçÆ‰∏çÂåÖÂê´ `ambu_path`ÔºåÂ∞±ÂøΩÁï•Êõ¥Êñ∞
        if (data.collection === "ambu_path") {
            ambuPathData = data.data || []; // Á°Æ‰øùÊï∞ÊçÆ‰∏ç‰∏∫Á©∫
            updateAmbulancePositions(ambulanceData, ambuPathData);
        } else {
            console.warn("‚ö†Ô∏è 'ambu_path' collection not found, skipping update.");
        }
    };

    ambulanceSocket.onerror = error => console.error("üö® Ambulance WebSocket Error:", error);
    ambuPathSocket.onerror = error => console.error("üö® Ambulance Path WebSocket Error:", error);
  }



  // Initialize both WebSocket connections
  initTrainWebSocket();
  initAmbulanceWebSocket();
  
//     // **ÂÆöÊúüÊõ¥Êñ∞Êï∞ÊçÆ**
//   setInterval(() => {
//     initAmbulanceWebSocket(); // ÊØè 5 ÁßíÈáçÊñ∞ËØ∑Ê±ÇÊï∞ÊçÆ
//   }, 5000);






  function railsegmentWebSocket() {
    const railsegmentSocket = new WebSocket("ws://localhost:8000/ws/scan");

    railsegmentSocket.onopen = () => {
        railsegmentSocket.send(JSON.stringify({ collection: "railsegment" })); // Request railsegment data
    };

    railsegmentSocket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        // console.log("Total Railsegments Received:", data.data.length);
        // console.log("Received Data:", data); // Debugging: Check full response

        if (data.collection === "railsegment" && Array.isArray(data.data)) {
            data.data.forEach(entry => {
                try {
                    const segmentId = entry[0];  // Segment ID
                    const geojsonStr = entry[1]; // GeoJSON as string
                    const metadataStr = entry[2][1]; // Extract the correct JSON string
                    const metadata = JSON.parse(metadataStr); // Parse metadata as JSON

                    const geojson = JSON.parse(geojsonStr); // Convert GeoJSON string to object
                    const coordinates = geojson.coordinates;

                    if (geojson.type === "Polygon") {
                        addPolygonToMap(coordinates, segmentId, metadata);
                    }
                } catch (error) {
                    console.error("üö® Error parsing segment:", entry, error);
                }
            });
        } else {
            console.warn("üö® Unexpected response format:", data);
        }
    };

    railsegmentSocket.onerror = (error) => console.error("WebSocket Error:", error);
  }

  function addPolygonToMap(coordinates, segmentId, metadata) {
    // console.log(`Rendering Segment: ${segmentId}`, coordinates);

    // Convert [lng, lat] ‚Üí [lat, lng] for Leaflet
    const formattedCoords = coordinates[0].map(coord => [coord[1], coord[0]]);

    // Create the polygon with enhanced transparency
    const polygon = L.polygon(formattedCoords, {
        color: "blue",      // Border color
        fillColor: "blue",  // Fill color
        weight: 2,          // Border thickness
        fillOpacity: 0.2    // Increased transparency
    }).addTo(map);

    // Automatically remove the polygon after 0.5 seconds
    setTimeout(() => {
        map.removeLayer(polygon);
    }, 500);

    // Bind a click event to show segment info
    polygon.on("click", () => {
        const popupContent = `<b>üöÜ Segment ID:</b> ${segmentId}<br>
                              <b>Status:</b> ${metadata.status || "Unknown"}<br>
                              <b>Shape Length:</b> ${metadata.SHAPE_Length || "N/A"}<br>
                              <b>Shape Area:</b> ${metadata.SHAPE_Area || "N/A"}`;
        polygon.bindPopup(popupContent).openPopup();
    });
}



  // railsegmentWebSocket();


</script>
</body>
</html>
